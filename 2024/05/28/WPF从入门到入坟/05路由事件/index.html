<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>WPF从入门到入坟 - 05路由事件 | 生活中的tree</title><meta name="author" content="大白"><meta name="copyright" content="大白"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="路由事件&emsp;&emsp;路由事件时具有更强传播能力的事件——它们可在元素树中向上冒泡和向下隧道传播，并且沿着传播路径被事件处理程序处理。路由事件允许事件在某个元素上被处理（如标签），即使该事件源自另一个元素（如标签内部的一幅图像）也是如此。与依赖项属性一样，可通过传统的方式使用路由事件——通过关联具有正确签名的事件处理程序——但为了使用路由事件的所有功能，需要理解其工作原理。 理解路由事件">
<meta property="og:type" content="article">
<meta property="og:title" content="WPF从入门到入坟 - 05路由事件">
<meta property="og:url" content="http://bootree.cn/2024/05/28/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/05%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6/index.html">
<meta property="og:site_name" content="生活中的tree">
<meta property="og:description" content="路由事件&emsp;&emsp;路由事件时具有更强传播能力的事件——它们可在元素树中向上冒泡和向下隧道传播，并且沿着传播路径被事件处理程序处理。路由事件允许事件在某个元素上被处理（如标签），即使该事件源自另一个元素（如标签内部的一幅图像）也是如此。与依赖项属性一样，可通过传统的方式使用路由事件——通过关联具有正确签名的事件处理程序——但为了使用路由事件的所有功能，需要理解其工作原理。 理解路由事件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png">
<meta property="article:published_time" content="2024-05-28T12:00:28.000Z">
<meta property="article:modified_time" content="2024-05-28T14:50:04.488Z">
<meta property="article:author" content="大白">
<meta property="article:tag" content="WPF从入门到入坟">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://bootree.cn/2024/05/28/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/05%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6/index.html"><link rel="preconnect" href="https://jsd.012700.xyz"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://jsd.012700.xyz/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://jsd.012700.xyz/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: 大白","link":"链接: ","source":"来源: 生活中的tree","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://jsd.012700.xyz/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'WPF从入门到入坟 - 05路由事件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-28 22:50:04'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><link rel="alternate" href="/atom.xml" title="生活中的tree" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png')"><nav id="nav"><span id="blog-info"><a href="/" title="生活中的tree"><span class="site-name">生活中的tree</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WPF从入门到入坟 - 05路由事件<a class="post-edit-link" href="https://github.com/cnlicm/HexoBlog/tree/main/source/_posts/WPF从入门到入坟/05路由事件.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-05-28T12:00:28.000Z" title="发表于 2024-05-28 20:00:28">2024-05-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/WPF/">WPF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="WPF从入门到入坟 - 05路由事件"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="路由事件"><a href="#路由事件" class="headerlink" title="路由事件"></a>路由事件</h2><p>&emsp;&emsp;路由事件时具有更强传播能力的事件——它们可在元素树中向上冒泡和向下隧道传播，并且沿着传播路径被事件处理程序处理。路由事件允许事件在某个元素上被处理（如标签），即使该事件源自另一个元素（如标签内部的一幅图像）也是如此。与依赖项属性一样，可通过传统的方式使用路由事件——通过关联具有正确签名的事件处理程序——但为了使用路由事件的所有功能，需要理解其工作原理。</p>
<h3 id="理解路由事件"><a href="#理解路由事件" class="headerlink" title="理解路由事件"></a>理解路由事件</h3><p>&emsp;&emsp;每个.NET开发人员都熟悉“事件”的思想--当有意义的事情发生时,由对象(如WPF元素)发送的用于通知代码的消息。WPF通过事件路由(event routing)的概念增强了.NET事件模型。事件路由允许源自某个元素的事件由另一个元素引发。例如,使用事件路由,来自工具栏按钮的单击事件可在被代码处理之前上传到工具栏,然后上传到包含工具栏的窗口。</p>
<h3 id="定义-注册和封装路由事件"><a href="#定义-注册和封装路由事件" class="headerlink" title="定义&#x2F;注册和封装路由事件"></a>定义&#x2F;注册和封装路由事件</h3><p>&emsp;&emsp;WPF事件模型和WPF属性模型非常类似。与依赖项属性一样,路由事件由只读的静态字段表示,在静态构造函数中注册,并通过标准的.NET事件定义进行封装。</p>
<pre><code>例如,WPF 的Button类提供了大家熟悉的Click事件,该事件继承自抽象的ButtonBase基类。下面的代码说明了该事件是如何被定义和注册的:
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ButtonBase</span> : <span class="title">ContentControl</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义路由事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> RoutedEvent ClickEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由事件</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ButtonBase</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ButtonBase.ClickEvent = EventManager.RegisterRoutedEvent(</span><br><span class="line">            <span class="string">&quot;Click&quot;</span>, <span class="comment">// 事件名称</span></span><br><span class="line">            RoutingStrategy.Bubble, <span class="comment">// 路由类型</span></span><br><span class="line">            <span class="keyword">typeof</span>(RoutedEventHandler), <span class="comment">// 事件处理程序语法的委托</span></span><br><span class="line">            <span class="keyword">typeof</span>(ButtonBase) <span class="comment">// 拥有事件的类</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装路由事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> RoutedEventHandler Click</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.AddHandler(ButtonBase.ClickEvent,<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.RemoveHandler(ButtonBase.ClickEvent,<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>依赖项属性是使用DependencyProperty. Register()方法注册的,而路由事件是使用EventManager.RegisterRoutedEvent()方法注册的。</p>
</div>

<h3 id="共享路由事件"><a href="#共享路由事件" class="headerlink" title="共享路由事件"></a>共享路由事件</h3><p>&emsp;&emsp;与依赖项属性一样，可在类之间共享路由事件的定义。例如，UIElement(该类是所有普通WPF 元素的起点)和ContentElement(该类是所有内容元素的起点，内容元素是可以被放入流文档中的单独内容片段)这两个基类都使用了MouseUp事件。MouseUp事件是由SvstemWindows.Input,.Mouse类定义的。UElement 类和 ContentElement类只通过Routed- Event.AddOwner()方法重用MouseUp事件:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIElement.MouseUpEvent = Mouse.MouseUpEvent.AddOwner(<span class="keyword">typeof</span>(UIElement));</span><br></pre></td></tr></table></figure>

<h3 id="引发路由事件"><a href="#引发路由事件" class="headerlink" title="引发路由事件"></a>引发路由事件</h3><p>&emsp;&emsp;路由事件不是通过传统的.NET事件封装器引发的，而是使用RaiseEvent()方法引发事件，所有元素都从UIElement类继承了该方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoutedEventArgs e = <span class="keyword">new</span> RoutedEventArgs(ButtonBase.ClickEvent,<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">base</span>.RaiseEvent(e); <span class="comment">// RaiseEvent()方法负责为每个已经通过 AddHandler()方法注册的调用程序引发事件。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所有WPF事件都为事件签名使用熟悉的.NET约定。每个事件处理程序的第一个参数（sender参数）都提供引发事件的对象的引用。第二个参数时EventArgs对象，该独显与其他所有可能很重要的附加细节绑定在一起。例如，MouseUp事件提供了一个MouseEventArgs对象，用于指示但事件发生时按下了哪些鼠标键：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">img_MouseUp</span>(<span class="params"><span class="built_in">object</span> sender,MouseButtonEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note info flat"><p>在WPF 中,如果事件不需要传递任何额外细节,可使用RoutedEventArgs类,该类包含了有关如何传递事件的一些细节。如果事件确实需要传递额外的信息,那么需要使用更特殊的继承自RoutedEventArgs的对象(如上面示例中的MouseButtonEventArgs)。因为每个WPF事件参数类都继承自RoutedEventArgs类,所以每个WPF事件处理程序都可访问与事件路由相关的信息。</p>
</div>

<h3 id="处理路由事件"><a href="#处理路由事件" class="headerlink" title="处理路由事件"></a>处理路由事件</h3><h4 id="XAML标记"><a href="#XAML标记" class="headerlink" title="XAML标记"></a>XAML标记</h4><p>&emsp;&emsp;最常用的方法是为XAML标记天机事件特性。通常约定“元素名_事件名”的形式明明事件处理程序方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">x:Name</span>=<span class="string">&quot;img&quot;</span> <span class="attr">Source</span>=<span class="string">&quot;happyface.jpg&quot;</span> <span class="attr">Stretch</span>=<span class="string">&quot;None&quot;</span> <span class="attr">MouseUp</span>=<span class="string">&quot;img_MouseUp&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="代码连接"><a href="#代码连接" class="headerlink" title="代码连接"></a>代码连接</h4><p>&emsp;&emsp;如果需要动态创建控件,并在窗口生命周期的某一时刻关联事件处理程序,代码方法是非常有用的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img.MouseUp += <span class="keyword">new</span> MouseButtonEventHandler(img_Mouseup); <span class="comment">// 完整写法</span></span><br><span class="line">img.MouseUp += img_MouseUp; <span class="comment">// 简写</span></span><br></pre></td></tr></table></figure>

<h4 id="事件封装器"><a href="#事件封装器" class="headerlink" title="事件封装器"></a>事件封装器</h4><p>&emsp;&emsp;当使用这种方法时，始终需要创建合适的委托类型，而不是能隐式地创建委托对象。这是因为UIElement.AddHandler()方法支持所有WPF事件，并且他不知道您要使用的委托类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.AddHandler(UIElement.MouseUpEvent,<span class="keyword">new</span> MouseButtonEventHandler(img_MouseUp));</span><br></pre></td></tr></table></figure>

<h4 id="断开事件处理程序"><a href="#断开事件处理程序" class="headerlink" title="断开事件处理程序"></a>断开事件处理程序</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img.MouseUp -= img_MouseUp;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">img.RemoveHandler(Imgae.MouseUpEvent,<span class="keyword">new</span> MouseButtonEventHandler(img_MouseUp));</span><br></pre></td></tr></table></figure>

<h2 id="事件路由"><a href="#事件路由" class="headerlink" title="事件路由"></a>事件路由</h2><p>&emsp;&emsp;WPF中的许多空间都是内容控件，而内容控件可包含任何类型以及大量的嵌套内容，因此恰当的事件标记处理可以避免处理程序变得杂乱无章。</p>
<pre><code>路由手机将实际上以下列三种方式出现：
</code></pre>
<ul>
<li><strong>直接路由事件（direct event）</strong>：与普通.NET事件类似，它们源于一个元素，不传递给其他元素，例如，MouseEnter事件（当鼠标指针移到元素上时发生）</li>
<li><strong>冒泡路由事件（bubbling event）</strong>：在包含层次中向上传递的，<code>通常鼠标事件都是冒泡路由事件</code>，例如，MouseDown事件，该事件首先由被单击的元素引发，接下来被该元素的父元素引发，然后被父元素的父元素引发，以此类推，直到WPF到达元素树顶部为止</li>
<li><strong>隧道路由事件（tunneling event）</strong>：在包含层次中向下传递，<code>通常以Preview开头的事件</code>，隧道路由事件在事件到达恰当的控件之前为预览事件（甚至终止事件）提供了机会，例如，通过PreviewKeyDown事件可截获时候按下了某个键。首先在窗口级别上，然后时更具体的容器，直到到达但按下键时具有焦点的元素。</li>
</ul>
<h3 id="RoutedEventArgs类"><a href="#RoutedEventArgs类" class="headerlink" title="RoutedEventArgs类"></a>RoutedEventArgs类</h3><p>&emsp;&emsp;在处理冒泡路由事件时，sender参数提供了对整个链条上最后那个链接的引用</p>
<center>RoutedEventArgs类的属性</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Source</td>
<td>指示引发了事件的对象</td>
</tr>
<tr>
<td>OriginalSource</td>
<td>指示最初时什么对象引发了事件</td>
</tr>
<tr>
<td>RoutedEvent</td>
<td>通过事件处理程序为出发的事件提供RoutedEvent对象</td>
</tr>
<tr>
<td>Handled</td>
<td>该属性允许终止事件的冒泡或隧道过程。如果控件将Handled属性设为true，那么事件就不会继续传递，也不会为其他任何元素引发该事件</td>
</tr>
</tbody></table>
<h3 id="处理挂起的事件"><a href="#处理挂起的事件" class="headerlink" title="处理挂起的事件"></a>处理挂起的事件</h3><p>&emsp;&emsp;AddHandler()方法提供了一个重载版本,该版本可以接收一个Boolean值作为它的第三个参数。如果将该参数设置为true,那么即使设置了Handled标志,也将接收到事件:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdClear.AddHandler(UIElement.MouseUpEvent,<span class="keyword">new</span> MouseButtonEventHandler(cmdClear_MouseUp),<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<div class="note warning flat"><p>这通常不是正确的设计决策。为防止可能造成的困惑，按钮被设计为会挂起MouseUp事件</p>
</div>

<h3 id="附加事件"><a href="#附加事件" class="headerlink" title="附加事件"></a>附加事件</h3><p>&emsp;&emsp;假设在StackPanel面板中封装了一堆按钮，并希望在一个事件处理程序中处理所有这些按钮的单击事件。。粗略的方法是将每个按钮的Click事件关联到同一个事件处理程序。但Click事件支持事件冒泡,从而提供了一种更好的选择。可通过处理更高层次元素的Click事件(如包含按钮的StackPanel面板)来处理所有按钮的Click事件。</p>
<div class="tabs" id="note"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="note-1">XML</button><button type="button" class="tab " data-href="note-2">C#</button></ul><div class="tab-contents"><div class="tab-item-content active" id="note-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span> <span class="attr">Button.Click</span> = <span class="string">&quot;DoSomething&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;cmd1&quot;</span> <span class="attr">Content</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;cmd2&quot;</span> <span class="attr">Content</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;cmd3&quot;</span> <span class="attr">Content</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;cmd4&quot;</span> <span class="attr">Content</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span> <span class="attr">Name</span>=<span class="string">&quot;cmd5&quot;</span> <span class="attr">Content</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="note-2"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sender == cmd1)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sender == cmd2)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<h3 id="隧道路由事件"><a href="#隧道路由事件" class="headerlink" title="隧道路由事件"></a>隧道路由事件</h3><p>&emsp;&emsp;隧道路由事件的工作方式和冒泡路由事件相同，但方向相反。隧道路由事件易于识别，它们都以单词 Preview开头。而且，WPF通常成对地定义冒泡路由事件和隧道路由事件。这意味着如果发现冒泡的MouseUp事件，就还可以找到PreviewMouseUp 隧道事件。隧道路由事件总在冒泡路由事件之前被触发</p>
<center>隧道路由事件和冒泡路由事件</center>

<img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/20240528212303.png" width="50%">

<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>如果准备将隧道路由事件标记为处理过，务必要谨慎从事。根据编写控件的方式，这有可能阻止控件处理自己的事件(相关的冒泡路由事件)，从而阻止执行某些任务或阻止更新控件自身的状态。</p>
</div>

<h2 id="WPF事件"><a href="#WPF事件" class="headerlink" title="WPF事件"></a>WPF事件</h2><p>&emsp;&emsp;尽管每个元素都提供了许多事件，但最重要的事件童话参观包括以下5类：</p>
<ul>
<li><strong>生命周期事件</strong>：在元素被初始化、加载或卸载时发生这些事件</li>
<li><strong>鼠标事件</strong>：这些事件时鼠标动作的结果</li>
<li><strong>键盘事件</strong>：这些事件时键盘动作（如按下键盘上的键）的结果</li>
<li><strong>手写笔事件</strong>：这些事件时使用类似钢笔的手写笔的结果，在平板电脑上用手写笔代替鼠标</li>
<li><strong>多点触控事件</strong>：这些事件时一根或多根手指在多点触控屏幕上触摸的结果。仅在Widdows7中支持这些事件</li>
</ul>
<h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件"></a>生命周期事件</h3><p>&emsp;&emsp;但首次创建以及释放所有元素时都会引发事件，可使用这些事件初始化窗口。</p>
<center>所有元素的生命周期事件</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Initialized</td>
<td>但元素被实例化，并已根据XAML标记设置了元素的属性之后发生。这是元素已经初始化，但窗口的其他部分可能尚未初始化。此外，尚未应用样式和数据绑定。这是，IsInitialized属性为true。Initialized事件时普通的.NET事件——并未路由事件</td>
</tr>
<tr>
<td>Loaded</td>
<td>当整个窗口已经初始化并应用了样式和数据绑定时，该事件发生。这是在元素被呈现之前的最后一站。这是，IsLoaded属性为true</td>
</tr>
<tr>
<td>Unloaded</td>
<td>当元素被释放时，该事件发生，原因时包含元素的窗口被关闭或特定的元素被从窗口中删除</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;为了弄清Initialized 事件和Loaded 事件之间的关系，分析一下呈现过程是有帮助的。FrameworkElement 类实现了 ISupportInitialize 接口，该接口提供了两个用于控制初始化过程的方法。</p>
<ol>
<li>第一个方法是 BeginInit()，在实例化元素后会立即调用该方法。调用 BeginInit( )方法后,XAML 解析器设置所有元素的属性(并添加内容)。</li>
<li>第二个方法是Endnit()，完成初始化后，将调用该方法，此时引发Initialized 事件。</li>
</ol>
<center>Window类的生命周期事件</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SourceInitialized</td>
<td>当取得窗口的HwndSource属性时（当在窗口可见之前）发生。HwndSource时窗口句柄，如果调用Win32 API中的遗留函数，就可能需要使用该句柄</td>
</tr>
<tr>
<td>ContentRendered</td>
<td>当窗口首次呈现后立即发生。对于执行任何可能会影响窗口可视外观的更改操作，这不是一个好位置，否则将会强制进行第二次呈现（改用Loaded事件）。然而，ContentRendered事件表明窗口已经完成可见，并且已经准备好接收输入</td>
</tr>
<tr>
<td>Activated</td>
<td>当用户切换到该窗口时发生(例如，从应用程序的其他窗口或从其他应用程序切换到该窗口)。当窗口第一次加载时也会引发 Activated 事件。从概念上讲，窗口的 Activated 事件相当于控件的 GotFocus 事件</td>
</tr>
<tr>
<td>Deactivated</td>
<td>当用户从该窗口切换到其他窗口时发生(例如，切换到应用程序的其他窗口或切换到其他应用程序)。当用户关闭窗口时也会发生该事件，该事件在Cosing事件之后，但在Closcd事件之前发生。从概念上讲，窗口的Deactivated 事件相当于控件的LostFocus事件</td>
</tr>
<tr>
<td>Closing</td>
<td>当关闭窗口时发生，不管是用户关闭窗口还是通过代码调用Window.Close()或Application.Shutdown()方法关闭窗口。Closing 事件提供了取消操作并保持打开状态的机会，具体通过将CancelEventArgs.Cancel 属性设置为true 实现该目标。但是，如果是因为用户关闭或注销计算机而导致应用程序被关闭，就不能接收到Closing事件。为应对这种情况，需要处理Application.SessionEnding 事件</td>
</tr>
<tr>
<td>Closed</td>
<td>当窗口已经关闭后发生。但是，此时仍可以访问元素对象，当然是在Unoaded.事件尚未发生之前。在此，可以执行一些清理工作，向永久存储位置(如配置文件或 Windows 注册表)写入设置信息等</td>
</tr>
</tbody></table>
<div class="note danger simple"><p>也可以使用窗口构造函数进行初始化(在紧跟 ImitializeComponent()调用之后,添加自己的代码)。<code>但使用Loaded 事件总是更好的选择</code>。这是因为如果在 Window 类的构造函数中发生异常，就会在 XAML解析器解析页面时抛出该异常。因此，该异常将与 InnerException 属性中的原始异常一起被封装到一个没有用处的XamlParseException 对象中。</p>
</div>

<h3 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a>输入事件</h3><p>&emsp;&emsp;输入事件是当用户使用某些种类的外设硬件进行交互时发生的事件，例如鼠标、键盘、手写笔或多点触控屏。输入事件可通过继承自InputEventArgs 的自定义事件参数类传递额外的信息。下图显示了继承层次。</p>
<center>输入事件的EventArgs类</center>

<p><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/20240528214735.png"></p>
<p>&emsp;&emsp;InputEventArgs 类只增加了两个属性:Timestamp和 Device。Timestamp 属性提供了一个整数，指示事件何时发生的毫秒数(它所代表的实际时间并不重要，但可比较不同的时间戳值以确定哪个事件先发生。时间戳值大的事件是在更近发生的)。Device 属性返回一个对象，该对象提供与触发事件的设备相关的更多信息，设备可以是鼠标、键盘或手写笔。这三种可能的设备由不同的类表示，所有这些类都继承自抽象类System.Windows.Input.InputDevice。</p>
<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>&emsp;&emsp;当用户按下键盘上的一个键时，就会发生一系列事件。下面根据它们发生的顺序列出了这些事件。</p>
<center>所有元素的键盘事件（按顺序）</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>路由类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PreviewKeyDown</td>
<td>隧道</td>
<td>当按下一个键时发生</td>
</tr>
<tr>
<td>KeyDown</td>
<td>冒泡</td>
<td>当按下一个键时发生</td>
</tr>
<tr>
<td>PreviewTextInput</td>
<td>隧道</td>
<td>当按键完成并且元素正在接收文本输入时发生。对于那些不会产生文本“输入”的按键(如 Ctr1键、Shif 键、Backspace 键、方向键和功能键等)，不会引发该事件</td>
</tr>
<tr>
<td>TextInput</td>
<td>冒泡</td>
<td>当按键完成并且元素正在接收文本输入时发生。对于那些不会产生文本的按键，不会引发该事件</td>
</tr>
<tr>
<td>PreviewKeyUp</td>
<td>隧道</td>
<td>当释放一个按键时发生</td>
</tr>
<tr>
<td>KeyUp</td>
<td>冒泡</td>
<td>当释放一个按键时发生</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;键盘处理永远不会像上面看到的这么简单。一些控件可能会挂起这些事件中的某些事件，从而可执行自己更特殊的键盘处理。最明显的例子是 TextBox 控件，它挂起了TextInput 事件。对于一些按键，TextBox 控件还挂起了KeyDown 事件，如方向键。对于此类情形，通常仍可使用隧道路由事件(PreviewTextInput和PreviewKeyDown 事件)。<br>&emsp;&emsp;TextBox 控件还添加了名为 TextChanged 的新事件。在按键导致文本框中的文本发生改变之后会立即引发该事件。这时，在文本框中已经可以看到新的文本，所以阻止不需要的按键已为时太晚。</p>
<h4 id="获取键盘状态"><a href="#获取键盘状态" class="headerlink" title="获取键盘状态"></a>获取键盘状态</h4><center>KeyboardDevice属性提供的方法</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IsKeyDown()</td>
<td>当事件发生时，通知时候按下了该键</td>
</tr>
<tr>
<td>IsKeyUp()</td>
<td>当事件发生时，通知时候释放了该键</td>
</tr>
<tr>
<td>IsKeyToggled()</td>
<td>当事件发生时，通知该键是否处于“打开”状态。该方法只对那些能够打开、关闭的键有意义，如 Caps Lock 键、Scroll Lock 键以及 Num Lock 键</td>
</tr>
<tr>
<td>GetKeyStates()</td>
<td>返回一个或多个 KeyStates 枚举值，指明该键当前是否被释放了、按下了或处于切换状态。该方法本质上和为同一个键同时调用IsKeyDown()方法和IsKeyToggled()方法相同</td>
</tr>
</tbody></table>
<div class="note info flat"><p>使用KeyConverter类将Key值转换为更有用的字符串。例如，使用KeyConverter.ConverterToString( )方法，Key.D9 和 Dey.NumPad9 都返回字符串“9”。如果只使用 Key.ToString()方法，将得到不那么有用的枚举名称(D9 或 NumPad9)</p>
</div>

<h3 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h3><p>&emsp;&emsp;鼠标事件执行几个关联的任务。当鼠标移到某个元素上时，可通过最基本的鼠标事件进行响应。这些事件是 MouseEnter(当鼠标指针移到元素上时引发该事件)和 MoseLeave(当鼠标指针离开元素时引发该事件)。这两个事件都是直接事件，这意味着它们不使用冒泡和隧道过程，而是源自一个元素并且只被该元素引发。考虑到控件嵌入到 WPF窗口的方式，这是合理的。</p>
<div class="note info flat"><p>UIElement 类还包含两个有用的属性，这两个属性能帮助进行鼠标命中测试。可使用IsMouseOver 属性确定当前鼠标是否位于某个元素及其子元素上面,还可以使用 IsMouseDirectlyOver属性检查鼠标是否位于某个元素上面，但未位于其子元素上面。通常不会在代码中读取和使用这些值，反而会使用它们构建样式触发器，从而当鼠标移到元素上时，自动修改元素。</p>
</div>

<h4 id="鼠标单击"><a href="#鼠标单击" class="headerlink" title="鼠标单击"></a>鼠标单击</h4><p>&emsp;&emsp;鼠标单击事件的引发方式和按键事件的引发方式有类似之处。区别是对于鼠标左键和鼠标右键引发不同的事件</p>
<center>所有元素的鼠标当单击事件（按顺序排列）</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>路由类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PreviewMouseLeftButtonDown、PreviewMouseRightButtonDown</td>
<td>隧道</td>
<td>当按下鼠标键时发生</td>
</tr>
<tr>
<td>MouseLeftButtonDown、MouseRightButtonDown</td>
<td>冒泡</td>
<td>当按下鼠标键时发生</td>
</tr>
<tr>
<td>PreviewMouseLeftButtonUp、PreivewMouseRightButtonUp</td>
<td>隧道</td>
<td>当释放鼠标键时发生</td>
</tr>
<tr>
<td>MouseLeftButtonUp、MouseRightButtonUp</td>
<td>冒泡</td>
<td>当释放鼠标键时发生</td>
</tr>
</tbody></table>
<div class="note info flat"><p>某些元素添加了更高级的鼠标事件。例如，Control类添加了PreviewMouseDoubleClick事件和 MouseDoubleClick 事件，这两个事件代替了MouseLeftButtonUp 事件。与此类似，对于Button类，通过鼠标或键盘可触发 Click事件。</p>
</div>

<h3 id="捕获鼠标"><a href="#捕获鼠标" class="headerlink" title="捕获鼠标"></a>捕获鼠标</h3><p>&emsp;&emsp;通常，元素每次接收到鼠标键“按下”事件后，不久后就会接收到对应的鼠标键“释放”事件。但情况不见得总是如此。例如，如果单击一个元素，保持按下鼠标键，然后移动鼠标指针离开该元素，这时该元素就不会接收到鼠标键释放事件。<br>&emsp;&emsp;某些情况下，可能希望通知鼠标键释放事件，即使鼠标键释放事件是在鼠标已经离开了原来的元素之后发生的。为此，需要调用Mouse.Capture()方法并传递恰当的元素以捕获鼠标。此后就会接收到鼠标键按下事件和释放事件，直到再次调用Mouse.Capture()方法并传递空引用为止。当鼠标被一个元素捕获后，其他元素就不会接收到鼠标事件。这意味着用户不能单击窗口中其他位置的按钮，不能单击文本框的内部。鼠标捕获有时用于可以被拖放并可以改变尺寸的元素。</p>
<div class="note info flat"><p>当调用 Mouse.Capture()方法时，可传递可选的 CaptureMode 值作为第二个参数。通常，当调用 Mouse.Capture()方法时，使用 CaptureMode.Element值，这表示元素总是接收鼠标事件。然而如果使用 CaptureMode.SubTree,鼠标事件就可以经过已单击的元素(假定这个元素是执行捕获的元素的子元素)。如果在子元素中已经使用了事件冒泡或隧道特性来监视鼠标事件,这是非常合理的。</p>
</div>

<p>&emsp;&emsp;有些情况下，可能由于其他原因(不是您的错)丢失鼠标捕获。例如，如果需要显示系统对话框，Windows 可能会释放鼠标捕获。如果当鼠标键释放事件发生后没有释放鼠标，并且用户单击了另一个应用程序中的窗口，也可能丢失鼠标捕获。无论哪种情况，都可以通过处理元素的 <code>LostMouseCapture</code> 事件来响应鼠标捕获的丢失。<br>&emsp;&emsp;当鼠标被一个元素捕获时，就不能与其他元素进行交互(例如，不能单击窗口中的其他元鼠标捕获通常用于短时间的操作，如拖放。素)。</p>
<div class="note warning simple"><p>不是使用 Mouse.Capture( )方法，而是改用 UIElement类提供的两个方法:CaptureMouse()和 ReleaseMouseCapture()。只在合适的元素上调用这些方法。这种方法的唯一限制是不允许使<br>用 CaptureMode.SubTree 选项。</p>
</div>

<h3 id="鼠标拖放"><a href="#鼠标拖放" class="headerlink" title="鼠标拖放"></a>鼠标拖放</h3><p>&emsp;&emsp;本质上，拖放操作通过以下三个步骤进行：</p>
<ol>
<li>用户点击元素（或选择元素中的一块特定区域），并保持鼠标键为按下状态。这是，某些信息被搁置起来，并且拖放操作开始</li>
<li>用户键鼠标移到其他元素上。如果该元素可接受正在拖动的内容的类型，鼠标指针会变成拖放图标，否则鼠标指针会变成内部有一条线的圆形</li>
<li>当用户释放鼠标键时，元素接受信息并决定如何处理接收到的信息。在没有释放鼠标键时，可按下Esc键取消该操作</li>
</ol>
<h2 id="多点触控输入"><a href="#多点触控输入" class="headerlink" title="多点触控输入"></a>多点触控输入</h2><p>&emsp;&emsp;多点触控(multi-touch)是通过触摸屏幕与应用程序进行交互的一种方式。多点触控输入和更传统的基于笔(pen-based)的输入的区别是多点触控识别手势(gesture)---用户可移动多根手指以执行常见操作的特殊方式。</p>
<div class="note info flat"><p>要获得 Windows7 能够识别的标准多点触控手势列表,请参阅  <a class="btn-beautify green small" target="_blank" rel="noopener" href="http://tinyurl.com/yawwhw2" 
  title="多点触控"><i class="far fa-hand-point-right"></i><span>多点触控</span></a></p>
</div>

<h3 id="多点触控的输入层级"><a href="#多点触控的输入层级" class="headerlink" title="多点触控的输入层级"></a>多点触控的输入层级</h3><p>&emsp;&emsp;WPF提供了三个独立的层次：</p>
<ul>
<li><strong>原始触控（raw touch）</strong>：这是最低级的支持，可访问用户执行的每个触控。缺点是由您的应用程序负责将单独的触控消息组合到一起，并对它们进行解释。如果不准备识别标准触摸手势，反而希望创建以独特方式响应多点触控输入的应用程序，使用原始触控是合理的。一个例子是绘图程序，例如 Windows7画图程序，该程序允许用户同时使用多根手指在触摸屏上绘图。</li>
<li><strong>操作（manipulation）</strong>：操作(manipulation):这是一个简便的抽象层，该层将原始的多点触控输入转换成更有意义的手势，与WPF控件将一系列MouseDown和MouseUp 事件解释为更高级的MouseDoubleClick事件很相似。WPF 支持的通用手势包括移动(pan)、缩放(zoom)、旋转(rotate)以及轻按(tap)。</li>
<li><strong>内置的元素支持（built-in element support）</strong>：内置的元素支持(built-in element support):有些元素已对多点触控事件提供了内置支持，从而不需要再编写代码。例如，可滚动的控件支持触控移动，如 ListBox、ListView、DataGrid、TextBox 以及 ScrollViewer.</li>
</ul>
<h3 id="原始触控"><a href="#原始触控" class="headerlink" title="原始触控"></a>原始触控</h3><p>&emsp;&emsp;与基本的鼠标和键盘事件一样，触控事件被内置到低级的UIElement以及ContentElement类。</p>
<center>所有元素的原始触控事件</center>

<table>
<thead>
<tr>
<th>名称</th>
<th>路由类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>PreiviewTouchDown</td>
<td>隧道</td>
<td>当用户触摸元素时发生</td>
</tr>
<tr>
<td>TouchDown</td>
<td>冒泡</td>
<td>当用户触摸元素时发生</td>
</tr>
<tr>
<td>PreviewTouchMove</td>
<td>隧道</td>
<td>当用户移动放到触摸屏上的手指时发生</td>
</tr>
<tr>
<td>TouchMove</td>
<td>冒泡</td>
<td>当用户移动放到触摸屏上的手指时发生</td>
</tr>
<tr>
<td>PreiviewTouchUp</td>
<td>隧道</td>
<td>当用户一开手指，结束触摸时发生</td>
</tr>
<tr>
<td>TouchUp</td>
<td>冒泡</td>
<td>当用户一开手指，结束触摸时发生</td>
</tr>
<tr>
<td>TouchEnter</td>
<td>无</td>
<td>当触点从元素外进入元素内时发生</td>
</tr>
<tr>
<td>TouchLeave</td>
<td>无</td>
<td>当触点离开元素时发生</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;所有这些事件都提供了一个 TouchEventArgs对象，该对象提供了两个重要成员。</p>
<ol>
<li>第一个是GetTouchPoint()方法，该方法返回触控事件发生位置的屏幕坐标(还有一些不怎么常用的数据例如触点的大小)。</li>
<li>第二个是 TouchDevice 属性，该属性返回一个 TouchDevice 对象。这里的技巧是将每个触点都视为单独设备。因此，如果用户在不同的位置按下了两根手指(同时按下或者先按下一根再按下另一根)，WPF将它们作为两个触控设备，并为每个触控设备指定唯一的ID。当用户移动这些手指，并且触控事件发生时，代码可以通过 TouchDevice.Id 属性区分两个触点</li>
</ol>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>&emsp;&emsp;WPF为手势提供了更高级别的支持，称为触控操作(manipulation)。通过将元素的 IsManipulationEnabled 属性设为 True，将元素配置为接受触控操作。然后可响应4个操作事件:ManipulationStarting、ManipulationStartedManipulationDelta 以及ManipulationCompleted.</p>
<h3 id="惯性"><a href="#惯性" class="headerlink" title="惯性"></a>惯性</h3><p>&emsp;&emsp;WPF 还有一层构建在基本操作支持之上的特性，称为惯性(intertia)。本质上，通过惯性可以更逼真、更流畅地操作元素。<br>&emsp;&emsp;只需处理 ManipulationInertiaStarting 事件。当用户结束手势并抬起手指释放元素时，触发 ManipulationInertiaStarting 事件。这时，可使用 ManipulationInertiaStartingEventsArgs 对象确定当前速度--当操作结束时元素的移动速度--并设置希望的减速度。下面的示例为移动、缩放以及旋转手势添加了惯性:</p>
<p>&emsp;&emsp;为使元素从障碍物自然地被弹回，需要在 ManipulationDelta 事件中检查是否将元素拖到了错误的位置。如果穿过了一条边界，那么由您负责通过调用ManipulationDeltaEventArgsReportBoundaryFeedback()方法进行报告。</p>
<div class="note info flat"><p>当参阅 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://multitouch.codeplex.com/">multitouch</a> 上的 WPF Multi-Touch项目。该项目提供了两种方便的方式，通过这两种方式可以为容器添加操作支持，而不需要自己编写代码--使用会自动应用的</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://bootree.cn">大白</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://bootree.cn/2024/05/28/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/05%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6/">http://bootree.cn/2024/05/28/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/05%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://bootree.cn" target="_blank">生活中的tree</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/">WPF从入门到入坟</a></div><div class="post_share"><div class="social-share" data-image="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://jsd.012700.xyz/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://jsd.012700.xyz/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/29/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/06%E6%8E%A7%E4%BB%B6/" title="WPF从入门到入坟 - 06控件"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WPF从入门到入坟 - 06控件</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/27/%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/git%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5github/" title="git通过ssh连接github"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/20240527200328.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git通过ssh连接github</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/22/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/01%E6%A6%82%E8%BF%B0/" title="WPF从入门到入坟 - 01概述"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-22</div><div class="title">WPF从入门到入坟 - 01概述</div></div></a></div><div><a href="/2024/05/25/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/04%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/" title="WPF从入门到入坟 - 04依赖属性"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-25</div><div class="title">WPF从入门到入坟 - 04依赖属性</div></div></a></div><div><a href="/2024/05/23/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/02XAML/" title="WPF从入门到入坟 - 02XAML"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/20240527195528.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-23</div><div class="title">WPF从入门到入坟 - 02XAML</div></div></a></div><div><a href="/2024/05/24/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/03%E5%B8%83%E5%B1%80/" title="WPF从入门到入坟 - 03布局"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/20240527195817.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-24</div><div class="title">WPF从入门到入坟 - 03布局</div></div></a></div><div><a href="/2024/05/29/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/06%E6%8E%A7%E4%BB%B6/" title="WPF从入门到入坟 - 06控件"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-29</div><div class="title">WPF从入门到入坟 - 06控件</div></div></a></div><div><a href="/2024/05/31/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/07Application%E7%B1%BB/" title="WPF从入门到入坟 - 07Application类"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">WPF从入门到入坟 - 07Application类</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">大白</div><div class="author-info__description">人不可能同时拥有青春和对青春的感受</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/cnlicm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cnlicm" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:codenobugs@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">A lazy guy. My dream is that generate electricity with love.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">路由事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">理解路由事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%B0%81%E8%A3%85%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">定义&#x2F;注册和封装路由事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">共享路由事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%91%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">引发路由事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">处理路由事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XAML%E6%A0%87%E8%AE%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">XAML标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">代码连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%B0%81%E8%A3%85%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">事件封装器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">断开事件处理程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">事件路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RoutedEventArgs%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">RoutedEventArgs类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%8C%82%E8%B5%B7%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">处理挂起的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">附加事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%A7%E9%81%93%E8%B7%AF%E7%94%B1%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">隧道路由事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WPF%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">WPF事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">生命周期事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">输入事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="toc-number">3.3.</span> <span class="toc-text">键盘输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%AE%E7%9B%98%E7%8A%B6%E6%80%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">获取键盘状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E8%BE%93%E5%85%A5"><span class="toc-number">3.4.</span> <span class="toc-text">鼠标输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E5%8D%95%E5%87%BB"><span class="toc-number">3.4.1.</span> <span class="toc-text">鼠标单击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E9%BC%A0%E6%A0%87"><span class="toc-number">3.5.</span> <span class="toc-text">捕获鼠标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E6%8B%96%E6%94%BE"><span class="toc-number">3.6.</span> <span class="toc-text">鼠标拖放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7%E8%BE%93%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">多点触控输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7%E7%9A%84%E8%BE%93%E5%85%A5%E5%B1%82%E7%BA%A7"><span class="toc-number">4.1.</span> <span class="toc-text">多点触控的输入层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E8%A7%A6%E6%8E%A7"><span class="toc-number">4.2.</span> <span class="toc-text">原始触控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">4.3.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%AF%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">惯性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/31/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/19%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" title="WPF从入门到入坟 - 19数据绑定"><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WPF从入门到入坟 - 19数据绑定"/></a><div class="content"><a class="title" href="/2024/07/31/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/19%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/" title="WPF从入门到入坟 - 19数据绑定">WPF从入门到入坟 - 19数据绑定</a><time datetime="2024-07-31T12:34:33.000Z" title="发表于 2024-07-31 20:34:33">2024-07-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/18%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0/" title="WPF从入门到入坟 - 18自定义元素"><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WPF从入门到入坟 - 18自定义元素"/></a><div class="content"><a class="title" href="/2024/07/27/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/18%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0/" title="WPF从入门到入坟 - 18自定义元素">WPF从入门到入坟 - 18自定义元素</a><time datetime="2024-07-27T07:38:23.000Z" title="发表于 2024-07-27 15:38:23">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/22/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/17%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF/" title="WPF从入门到入坟 - 17控件模板"><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WPF从入门到入坟 - 17控件模板"/></a><div class="content"><a class="title" href="/2024/07/22/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/17%E6%8E%A7%E4%BB%B6%E6%A8%A1%E6%9D%BF/" title="WPF从入门到入坟 - 17控件模板">WPF从入门到入坟 - 17控件模板</a><time datetime="2024-07-22T12:49:31.000Z" title="发表于 2024-07-22 20:49:31">2024-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/16/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/16%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB/" title="WPF从入门到入坟 - 16高级动画"><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WPF从入门到入坟 - 16高级动画"/></a><div class="content"><a class="title" href="/2024/07/16/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/16%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB/" title="WPF从入门到入坟 - 16高级动画">WPF从入门到入坟 - 16高级动画</a><time datetime="2024-07-16T12:46:14.000Z" title="发表于 2024-07-16 20:46:14">2024-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/13/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/15%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/" title="WPF从入门到入坟 - 15动画基础"><img src= "/img/loading.gif" data-lazy-src="https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WPF从入门到入坟 - 15动画基础"/></a><div class="content"><a class="title" href="/2024/07/13/WPF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/15%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/" title="WPF从入门到入坟 - 15动画基础">WPF从入门到入坟 - 15动画基础</a><time datetime="2024-07-13T03:36:42.000Z" title="发表于 2024-07-13 11:36:42">2024-07-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cnlicm-blog-image.oss-cn-shenzhen.aliyuncs.com/img/wpf.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 大白</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/"><img class="icp-icon" src= "/img/loading.gif" data-lazy-src="/img/2020011362.png"><span>赣ICP备2020011362号-2</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly@4.13.0/source/js/utils.min.js"></script><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly@4.13.0/source/js/main.min.js"></script><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly@4.13.0/source/js/tw_cn.min.js"></script><script src="https://jsd.012700.xyz/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://jsd.012700.xyz/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://jsd.012700.xyz/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://jsd.012700.xyz/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script data-pjax src="/self/btf.js"></script><script defer="defer" id="ribbon" src="https://jsd.012700.xyz/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script src="https://jsd.012700.xyz/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/talking/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="https://jsd.012700.xyz/npm/hexo-theme-butterfly@4.13.0/source/js/search/local-search.min.js"></script></div></div></body></html>